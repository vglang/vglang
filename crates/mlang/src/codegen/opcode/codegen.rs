use proc_macro2::TokenStream;
use quote::quote;

use crate::codegen::{
    opcode::{
        gen_attr_definition, gen_data_definition, gen_el_definition, gen_leaf_definition,
        gen_opcode_definition, gen_sexpr_mod, gen_variable_mod, TypeDefinition,
    },
    CodeGen, EnumCodeGen, FieldAttrs, FieldType, NodeCodeGen,
};

/// `mlang` core codes generator.
#[derive(Default)]
pub struct OpcodeCodeGen {
    node_gens: Vec<OpcodeNodeCodeGen>,
    enum_gens: Vec<OpcodeEnumCodeGen>,
    attr_fileds: Vec<TokenStream>,
    el_fileds: Vec<TokenStream>,
    leaf_fields: Vec<TokenStream>,
    data_fields: Vec<TokenStream>,
    child_of: Vec<(TokenStream, TokenStream)>,
    apply_to: Vec<(TokenStream, TokenStream)>,
}

impl CodeGen for OpcodeCodeGen {
    type Node = OpcodeNodeCodeGen;

    type Enum = OpcodeEnumCodeGen;

    fn create_node(
        &mut self,
        comments: TokenStream,
        ident: TokenStream,
        tuple: bool,
    ) -> Self::Node {
        OpcodeNodeCodeGen {
            comments,
            ident,
            fields: Default::default(),
            tuple,
        }
    }

    fn create_enum(&mut self, comments: TokenStream, ident: TokenStream) -> Self::Enum {
        OpcodeEnumCodeGen {
            comments,
            ident,
            fields: Default::default(),
        }
    }

    fn push_el(&mut self, el: Self::Node) {
        self.el_fileds.push(el.ident.clone());
        self.node_gens.push(el);
    }

    fn push_leaf(&mut self, el: Self::Node) {
        self.leaf_fields.push(el.ident.clone());
        self.node_gens.push(el);
    }

    fn push_attr(&mut self, el: Self::Node) {
        self.attr_fileds.push(el.ident.clone());
        self.node_gens.push(el);
    }

    fn push_data(&mut self, el: Self::Node) {
        self.data_fields.push(el.ident.clone());
        self.node_gens.push(el);
    }

    fn push_enum(&mut self, node: Self::Enum) {
        self.data_fields.push(node.ident.clone());
        self.enum_gens.push(node);
    }

    fn push_apply_to(&mut self, from: TokenStream, to: TokenStream) {
        self.apply_to.push((from, to));
    }

    fn push_child_of(&mut self, from: TokenStream, to: TokenStream) {
        self.child_of.push((from, to));
    }

    fn gen(self) -> TokenStream {
        let mut definitions = self
            .node_gens
            .iter()
            .map(|node| node.gen_type_definition())
            .chain(self.enum_gens.iter().map(|node| node.gen_type_definition()))
            .collect::<Vec<_>>();

        definitions.push(gen_el_definition(&self.el_fileds));
        definitions.push(gen_leaf_definition(&self.leaf_fields));
        definitions.push(gen_attr_definition(&self.attr_fileds));
        definitions.push(gen_data_definition(&self.data_fields));
        definitions.push(gen_opcode_definition());

        let variable_mod = gen_variable_mod();
        let sexpr_mod = gen_sexpr_mod(
            &self.el_fileds,
            &self.leaf_fields,
            &self.apply_to,
            &self.child_of,
        );

        quote! {
            /// This mod is automatically generated by `mlang`, please do not modify it manully.
            pub mod opcode {
                #(#definitions)*
            }

            /// This mod is automatically generated by `mlang`, please do not modify it manully.
            pub mod variable {
                #variable_mod
            }

            /// This mod is automatically generated by `mlang`, please do not modify it manully.
            pub mod sexpr {
                #sexpr_mod
            }
        }
    }
}

#[allow(unused)]
#[derive(Clone)]
pub(super) struct OpcodeFieldGen {
    pub(super) comments: TokenStream,
    pub(super) ident: Option<TokenStream>,
    pub(super) attrs: FieldAttrs,
    pub(super) ty: FieldType,
}

/// The core `el/leaf/..,etc` code generator
#[allow(unused)]
#[derive(Clone)]
pub struct OpcodeNodeCodeGen {
    pub(super) comments: TokenStream,
    pub(super) ident: TokenStream,
    pub(super) fields: Vec<OpcodeFieldGen>,
    pub(super) tuple: bool,
}

impl NodeCodeGen for OpcodeNodeCodeGen {
    fn push_field(
        &mut self,
        comments: TokenStream,
        ident: Option<TokenStream>,
        attrs: FieldAttrs,
        ty: FieldType,
    ) {
        assert_eq!(
            self.tuple,
            ident.is_none(),
            "field named/unnamed constraint failed."
        );

        self.fields.push(OpcodeFieldGen {
            comments,
            ident,
            attrs,
            ty,
        });
    }
}

/// The core `enum` code generator
#[allow(unused)]
pub struct OpcodeEnumCodeGen {
    pub(super) comments: TokenStream,
    pub(super) ident: TokenStream,
    pub(super) fields: Vec<OpcodeNodeCodeGen>,
}

impl EnumCodeGen for OpcodeEnumCodeGen {
    type Node = OpcodeNodeCodeGen;

    fn create_field(
        &mut self,
        comments: TokenStream,
        ident: TokenStream,
        tuple: bool,
    ) -> Self::Node {
        OpcodeNodeCodeGen {
            comments,
            ident,
            fields: Default::default(),
            tuple,
        }
    }

    fn push_field(&mut self, el: Self::Node) {
        self.fields.push(el);
    }
}
