//! `mlang` code generator for rust language.

pub mod mapping;

mod opcode;
pub use opcode::*;

mod ext {
    use std::{io::Result, path::Path};

    use proc_macro2::TokenStream;
    use quote::quote;

    use crate::lang::{ir::Stat, rustgen::gen_opcode_mod};

    fn write_and_fmt_rs<C: AsRef<[u8]>, P: AsRef<Path>>(path: P, content: C) -> Result<()> {
        std::fs::write(path.as_ref(), content)?;

        std::process::Command::new("rustfmt")
            .arg(path.as_ref())
            .output()?;

        Ok(())
    }

    /// Generate rust source codes.
    pub fn codegen(
        stats: impl AsRef<[Stat]>,
        target: impl AsRef<Path>,
        without_ext: bool,
    ) -> Result<()> {
        let mods = vec![("opcode", |stats: &[Stat]| gen_opcode_mod(stats))];

        if !without_ext {}

        let mut impls = vec![];

        for (name, gen) in mods {
            let codes = gen(stats.as_ref());

            let target_file = target.as_ref().join(format!("{}.rs", name));

            write_and_fmt_rs(target_file, codes.to_string())?;

            let ident = name.parse::<TokenStream>().unwrap();

            impls.push(quote! {
                pub mod #ident;
            });
        }

        let codes = quote! {
            //! This module is automatically generated by the ml compiler, do not modify it manually.

            #(#impls)*
        };

        let target_file = target.as_ref().join("mod.rs");

        write_and_fmt_rs(target_file, codes.to_string())?;

        Ok(())
    }
}

pub use ext::*;
