//! `mlang` code generator for rust language.

pub mod mapping;

mod opcode;
pub use opcode::*;
mod serde;
pub use serde::*;
mod sexpr;
pub use sexpr::*;

mod ext {
    use std::{
        io::{Error, ErrorKind, Result},
        path::Path,
    };

    use proc_macro2::TokenStream;
    use quote::quote;

    use crate::lang::{ir::Stat, rustgen::gen_opcode_mod};

    use super::{gen_serde_mod, gen_sexpr_mod};

    fn write_and_fmt_rs<C: AsRef<[u8]>, P: AsRef<Path>>(path: P, content: C) -> Result<()> {
        println!("codegen({:?}):", path.as_ref());

        std::fs::write(path.as_ref(), content).map_err(|err| {
            Error::new(
                ErrorKind::Other,
                format!("write file {:?} error: {}", path.as_ref(), err),
            )
        })?;

        println!("    write file ... ok");

        std::process::Command::new("rustfmt")
            .arg(path.as_ref())
            .output()
            .map_err(|err| {
                Error::new(
                    ErrorKind::Other,
                    format!("run rustfmt for {:?} error: {}", path.as_ref(), err),
                )
            })?;

        println!("    run rustfmt ... ok");

        Ok(())
    }

    /// Generate rust source codes.
    pub fn codegen(
        stats: impl AsRef<[Stat]>,
        target: impl AsRef<Path>,
        without_ext: bool,
    ) -> Result<()> {
        let mut mods = vec![("opcode", gen_opcode_mod(stats.as_ref()))];

        if !without_ext {
            mods.push(("sexpr", gen_sexpr_mod(stats.as_ref())));
            mods.push(("serde", gen_serde_mod(stats.as_ref())));
        }

        let mut impls = vec![];

        for (name, codes) in mods {
            let target_file = target
                .as_ref()
                .join(format!("{}.rs", name))
                .canonicalize()?;

            write_and_fmt_rs(target_file, codes.to_string())?;

            let ident = name.parse::<TokenStream>().unwrap();

            impls.push(quote! {
                pub mod #ident;
            });
        }

        let codes = quote! {
            //! This module is automatically generated by the ml compiler, do not modify it manually.

            #(#impls)*
        };

        let target_file = target.as_ref().join("mod.rs").canonicalize()?;

        write_and_fmt_rs(target_file, codes.to_string())?;

        Ok(())
    }
}

pub use ext::*;
