use std::collections::HashMap;

use heck::{ToSnakeCase, ToUpperCamelCase};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::opcode::{Enum, Ident, Node, Opcode, Property, Type};

/// The rust code generator for `mlang`.
#[allow(unused)]
#[derive(Default)]
pub struct CodeGen {
    /// The flag to open nodes restraint check code generating, default is true.
    restraint: bool,
    /// The flag to open s-expr codes generating, default is true.
    sexpr: bool,
    /// generated nodes definition codes.
    token_streams: Vec<TokenStream>,
    /// Group index
    group: HashMap<String, usize>,
    /// apply to restraints.
    apply_to: Vec<usize>,
    /// children of restraints.
    children_of: Vec<usize>,
    /// All element nodes.
    els: Vec<String>,
    /// All leaf nodes.
    leaves: Vec<String>,
    /// All attribute nodes.
    attrs: Vec<String>,
    /// All Data nodes.
    datas: Vec<String>,
}

impl CodeGen {
    /// Generate rust codes from `opcodes`.
    pub fn gen(mut self, opcodes: &[Opcode]) -> TokenStream {
        self.gen_nodes(opcodes);
        let nodes = &self.token_streams;
        quote! {
            //! This file is automatically generated by mlang, do not modify it manually!
            //!

            pub mod variables {
            /// The path used by [`Variable`] is used to point to [`Target`].
            #[derive(Debug, PartialEq, PartialOrd, Clone)]
            #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
            pub enum Path {
                /// Reference by name.
                Named(String),
                /// Reference by optimized position.
                Index(usize),
            }

            impl From<String> for Path {
                fn from(value: String) -> Self {
                    Self::Named(value)
                }
            }

            impl From<&str> for Path {
                fn from(value: &str) -> Self {
                    Self::Named(value.to_owned())
                }
            }

            impl From<usize> for Path {
                fn from(value: usize) -> Self {
                    Self::Index(value)
                }
            }

            /// The type of variable pointed to by [`Path`].
            #[derive(Debug, PartialEq, PartialOrd, Clone)]
            #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
            pub enum Target {
                /// Target is animation register.
                Register,
                /// Target is `item` variable returns by `foreach` iterator.
                ForeachItem,
                /// Target is `index` variable returns by `foreach` iterator.
                ForeachIndex,
                /// Target is `index` variable returns by `for range` iterator.
                Range,
            }

            /// Variable used by property fields.
            #[derive(Debug, PartialEq, PartialOrd, Clone)]
            #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
            pub enum Variable<T>
            where
                super::Data: From<T>,
            {
                /// A literal constant value.
                Constant(T),

                Reference {
                    path: Path,
                    target: Target,
                },
            }

            impl<T> From<T> for Variable<T>
            where
                super::Data: From<T>,
            {
                fn from(value: T) -> Self {
                    Self::Constant(value)
                }
            }

            impl<T> Default for Variable<T>
            where
                T: Default,
                super::Data: From<T>,
            {
                fn default() -> Self {
                    Self::Constant(T::default())
                }
            }

            impl<P, T> From<(P, Target)> for Variable<T>
            where
                super::Data: From<T>,
                Path: From<P>,
            {
                fn from(value: (P, Target)) -> Self {
                    Self::Reference {
                        path: value.0.into(),
                        target: value.1,
                    }
                }
            }
            }


            #(#nodes)*
        }
    }

    fn filed_ident_declare(&self, ident: &Ident) -> TokenStream {
        match ident.0.as_str() {
            "in" => "r#in".parse().unwrap(),
            "type" => "r#type".parse().unwrap(),
            i => i.to_snake_case().parse().unwrap(),
        }
    }

    fn type_ident_declare(&self, ident: &Ident) -> TokenStream {
        ident.0.to_upper_camel_case().parse().unwrap()
    }

    fn ty_declare(&mut self, ty: &Type, properties: &[Property]) -> TokenStream {
        let mut optional = false;
        let mut variable = false;

        for property in properties {
            for expr in &property.params {
                match expr.ident.0.as_str() {
                    "option" => optional = true,
                    "variable" => variable = true,
                    _ => {}
                }
            }
        }

        let token_stream = match ty {
            Type::Bool(_) => quote! {bool},
            Type::String(_) => quote! {String},
            Type::Byte(_) => quote! {i8},
            Type::Ubyte(_) => quote! {u8},
            Type::Short(_) => quote! {i16},
            Type::Ushort(_) => quote! {u16},
            Type::Int(_) => quote! {i32},
            Type::Uint(_) => quote! {u32},
            Type::Long(_) => quote! {i64},
            Type::Ulong(_) => quote! {u64},
            Type::Float(_) => quote! {f32},
            Type::Double(_) => quote! {f64},
            Type::Data(ident) => ident.0.parse().unwrap(),
            Type::ListOf(component, _) => {
                let component = self.ty_declare(component, &[]);

                quote! { Vec<#component> }
            }
            Type::ArrayOf(component, lit_num, _) => {
                let component = self.ty_declare(component, &[]);
                let len = lit_num.0;
                quote! { [#component;#len] }
            }
        };

        if optional {
            if variable {
                quote! { Option<variables::Variable<#token_stream>> }
            } else {
                quote! { Option<#token_stream> }
            }
        } else {
            token_stream
        }
    }

    fn gen_nodes(&mut self, opcodes: &[Opcode]) {
        for (index, opcode) in opcodes.iter().enumerate() {
            match opcode {
                Opcode::Element(node) => {
                    self.els.push(node.ident.0.clone());
                    self.gen_node(node)
                }
                Opcode::Leaf(node) => {
                    self.leaves.push(node.ident.0.clone());
                    self.gen_node(node)
                }

                Opcode::Attr(node) => {
                    self.attrs.push(node.ident.0.clone());
                    self.gen_node(node)
                }
                Opcode::Mixin(_) => {}
                Opcode::Data(node) => {
                    self.datas.push(node.ident.0.clone());
                    self.gen_node(node)
                }
                Opcode::Enum(node) => {
                    self.datas.push(node.ident.0.clone());
                    self.gen_enum(node);
                }
                Opcode::Group(group) => {
                    if self.restraint {
                        self.group.insert(group.ident.0.clone(), index);
                    }
                }
                Opcode::ApplyTo(_) => {
                    if self.restraint {
                        self.apply_to.push(index);
                    }
                }
                Opcode::ChildrenOf(_) => {
                    if self.restraint {
                        self.children_of.push(index);
                    }
                }
            }
        }

        self.gen_data_ty();
        self.gen_opcode_ty();

        if self.restraint {
            self.gen_restraint();
        }
    }

    fn gen_data_ty(&mut self) {
        let mut fields = vec![];
        let mut froms = vec![];

        let builtin_types = vec![
            ("bool", "bool"),
            ("byte", "i8"),
            ("ubyte", "u8"),
            ("short", "i16"),
            ("ushort", "u16"),
            ("int", "i32"),
            ("uint", "u32"),
            ("long", "i64"),
            ("ulong", "u64"),
            ("float", "f32"),
            ("double", "f64"),
        ];

        for (ident, ty) in builtin_types {
            let name = ident.to_upper_camel_case();
            let ty: TokenStream = ty.parse().unwrap();

            let ident: TokenStream = name.parse().unwrap();
            let list_ident = format_ident!("ListOf{}", name);

            fields.push(quote! {
                #ident(#ty),
                #list_ident(Box<Vec<#ty>>),
            });

            froms.push(quote! {
                impl From<#ty> for Data {
                    fn from(value: #ty) -> Self {
                        Data::#ident(value)
                    }
                }

                impl From<Vec<#ty>> for Data {
                    fn from(value: Vec<#ty>) -> Self {
                        Data::#list_ident(Box::new(value))
                    }
                }
            });
        }

        for data in &self.datas {
            let name = data.to_upper_camel_case();

            let ident: TokenStream = name.parse().unwrap();
            let list_ident = format_ident!("ListOf{}", name);

            fields.push(quote! {
                #ident(Box<#ident>),
                #list_ident(Box<Vec<#ident>>),
            });

            froms.push(quote! {
                impl From<#ident> for Data {
                    fn from(value: #ident) -> Self {
                        Data::#ident(Box::new(value))
                    }
                }

                impl From<Vec<#ident>> for Data {
                    fn from(value: Vec<#ident>) -> Self {
                        Data::#list_ident(Box::new(value))
                    }
                }
            });
        }

        self.token_streams.push(quote! {

            /// the data types that can be passed to the animation registers.
            #[derive(Debug, Clone, PartialEq, PartialOrd)]
            #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
            pub enum Data {
                #(#fields)*
            }

            #(#froms)*
        });
    }

    fn gen_opcode_ty(&mut self) {}

    fn gen_restraint(&mut self) {}

    fn gen_enum(&mut self, node: &Enum) {
        let ident = self.type_ident_declare(&node.ident);
        let comments = node
            .comments
            .iter()
            .map(|c| format!("///{}", c.0))
            .collect::<Vec<_>>()
            .join("\n")
            .parse::<TokenStream>()
            .unwrap();

        if node.fields.is_empty() {
            self.token_streams.push(quote! {
                #comments
                pub enum #ident;
            });
            return;
        }

        let mut fields = vec![];

        for field in &node.fields {
            fields.push(self.gen_node_inner(&field, true));
        }

        self.token_streams.push(quote! {
            #comments
            #[derive(Debug, PartialEq, PartialOrd, Clone)]
            #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
            pub enum #ident {
                #(#fields)*
            }
        });
    }

    fn gen_node(&mut self, node: &Node) {
        let token_stream = self.gen_node_inner(node, false);

        self.token_streams.push(token_stream);
    }
    fn gen_node_inner(&mut self, node: &Node, is_enum: bool) -> TokenStream {
        let ident = self.type_ident_declare(&node.ident);
        let comments = node
            .comments
            .iter()
            .map(|c| format!("///{}", c.0))
            .collect::<Vec<_>>()
            .join("\n")
            .parse::<TokenStream>()
            .unwrap();

        if node.fields.is_empty() {
            if is_enum {
                return quote! {
                    #comments
                    #ident,
                };
            } else {
                return quote! {
                    #comments
                    pub struct #ident;
                };
            }
        }

        let mut fields = vec![];

        for field in &node.fields {
            let ty = self.ty_declare(&field.ty, &field.properties);

            if let Some(ident) = &field.ident {
                let ident = self.filed_ident_declare(ident);

                if is_enum {
                    fields.push(quote! {
                        #ident: #ty,
                    });
                } else {
                    fields.push(quote! {
                        pub #ident: #ty,
                    });
                }
            } else {
                if is_enum {
                    fields.push(quote! {
                        #ty,
                    });
                } else {
                    fields.push(quote! {
                        pub #ty,
                    });
                }
            }
        }

        if node
            .fields
            .first()
            .map(|f| f.ident.is_some())
            .unwrap_or(false)
        {
            if is_enum {
                return quote! {
                    #comments
                    #ident {
                        #(#fields)*
                    },
                };
            } else {
                return quote! {
                    #comments
                    #[derive(Debug, PartialEq, PartialOrd, Clone)]
                    #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
                    pub struct #ident {
                        #(#fields)*
                    }
                };
            }
        } else {
            if is_enum {
                return quote! {
                    #comments
                    #ident(#(#fields)*),
                };
            } else {
                return quote! {
                    #comments
                    #[derive(Debug, PartialEq, PartialOrd, Clone)]
                    #[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
                    pub struct #ident(#(#fields)*);
                };
            }
        }
    }
}
