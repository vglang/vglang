//! intermediate representation generated by parser that are used to
//! help semantic analyze and opcode generating.

use parserc::Span;

use crate::opcode::{
    variable::{Path, Target},
    Color, Coords, Length, Rgb,
};

/// Ident token.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct Ident(pub String, pub Span);

/// A named register reference.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct NamedRegister(pub Ident, pub Span);

/// Literal integer: integer ::= [+-]? [0-9]+
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct LitBool(pub bool, pub Span);

/// Exponent part of a literal number.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct LitExp(pub i64, pub Span);

/// The sign part of a literal number.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct LitSign(pub bool, pub Span);

/// The number part of a literal number.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub enum LitRadix {
    Decimal(usize, Span),
    Hex(usize, Span),
    Binary(usize, Span),
}

/// Literal integer: integer ::= [+-]? [0-9]+
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct LitInt {
    pub span: Span,
    pub sign: Option<LitSign>,
    pub radix: LitRadix,
    pub exp: Option<LitExp>,
}

/// Literal num: integer ([Ee] integer)? | [+-]? [0-9]* "." [0-9]+ ([Ee] integer)?
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct LitNum {
    /// The span of literal number.
    pub span: Span,
    /// optional sign part.
    pub sign: Option<LitSign>,
    /// the integer part.
    pub trunc: usize,
    /// the fractionl part.
    pub fract: usize,
    /// optional exponent part.
    pub exp: Option<LitExp>,
}

/// Literal string: "hello", or 'hello'
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct LitStr(pub String, pub Span);

/// Literal color data.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub enum LitColor {
    Recognized(Color, Span),
    Rgb(Rgb, Span),
}

/// Literal coordinate unit: UserSpaceOnUse or ObjectBoundingBox.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct LitCoords(pub Coords, pub Span);

/// literal length value: 10cm, 2em
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct LitLength(pub Length, pub Span);

/// Literal expr variant.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub enum LitExpr {
    Bool(LitBool),
    Int(LitInt),
    Number(LitNum),
    Color(LitColor),
    Str(LitStr),
    Coords(LitCoords),
    Length(LitLength),
    Variable(Path, Target),
}

/// A custom attribute for function call.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct Attr {
    /// The span of this attribute.
    span: Span,
    /// Attribute call list.
    calls: Vec<CallExpr>,
}

/// A function call expr.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct CallExpr {
    /// The span of this fn call.
    span: Span,
    /// custom attributes apply to this fn call.
    attrs: Vec<Attr>,
    /// call target function name.
    target: Ident,
    /// function call parameter list.
    params: Vec<LitExpr>,
}

/// The type of fn parameter.
#[derive(Debug, PartialEq, PartialOrd, Clone, Copy)]
pub enum Type {
    Int(Span),
    Number(Span),
    Str(Span),
    Length(Span),
    Color(Span),
    Coords(Span),
}

/// A fn parameter.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct Param {
    /// The span of this param.
    span: Span,
    /// name of this parameter.
    name: Ident,
    /// Parameter type.
    ty: Type,
}

/// A graphic fn declare expr.
#[derive(Debug, PartialEq, PartialOrd, Clone)]
pub struct Fn {
    /// The span of this fn.
    span: Span,
    /// name of this fn.
    name: Ident,
    /// fn parameter list.
    params: Vec<Param>,
}
